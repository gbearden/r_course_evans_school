<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Part 4 - Adding more tools to your Tidyverse toolbox</title>
    <meta charset="utf-8" />
    <meta name="author" content="Graham Bearden" />
    <meta name="date" content="2021-11-04" />
    <script src="libs/header-attrs-2.11/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis-fonts.css" rel="stylesheet" />
    <link href="libs/countdown-0.3.5/countdown.css" rel="stylesheet" />
    <script src="libs/countdown-0.3.5/countdown.js"></script>
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Part 4 - Adding more tools to your Tidyverse toolbox
### Graham Bearden
### University of Washington
### November 4, 2021

---


# Preamble

- Reminder: Submit 2 “stakeholder-ready” data visualizations on November 11 or before
- How do you clean up your RStudio environment?
  - `rm()`
- When I aggregate my data, it always says: "`summarise() has grouped output by [SOME_VARIABLE]. You can override using the .groups argument`." What does that mean?
  - grouping and ungrouping
- Errors: good or bad?



---

# Preamble

What does "Stakeholder-ready" mean?
- Write a plot title
- Label the axes 
- Use a theme
- Do not include `NA`s in the plot (geom or legend)  

Other things to do when you submit your assignment
- Use `ggsave()` to export plots
- When you submit your assignment, submit your code and both plots

---

# What we learned in the previous class

- Overview of ggplot2  
- Building bar, line, scatter, and histogram plots  
  - Aggregated data
  - Disaggregated data
- Customizing plots

---

# What we'll learn today  

- More ways to use logical conditions for filtering and changing variable values
- How to "pivot" data, turning columns into rows and rows into columns
- How to merge two datasets
- Creating panels of plots with facets
- Counting cumulatively with `cumsum()`

---

# A reminder on troubleshooting

- Run code line by line  
- Ensure the code finished running (`+`s vs. `&gt;`s in the R console)  
- Red "x" annotation beside line numbers (after saving your file)

![](./figures/red_x_example.png)

---

# Troubleshooting exercise 

This code contains 4 mistakes. The code is supposed to create a plot of rentals by latitude and longitude, excluding rentals without ratings. The colors of points should be from the high charts color palette (`hc`). *HINT: It is possible to successfully produce the plot after correcting 3 mistakes, but the colors of the points will be from the default colors palette, not from the high charts palette. Why?*  

```r
library(tidyverse)
library(ggthemes)
        
airbnb &lt;- read_csv('https://bit.ly/3oadz2L')

airbnb %&gt;% 
  filter(! is.na(rating) %&gt;% 
  ggplot(aes(x = longitude, y = latitude, color = adress)) + 
  geom_point(alpha = .6) + 
  scale_fill_hc() + 
  theme_bw() 
  labs(
    x = 'Longitude'
    , y = 'Latitude'
    , color = 'City'
    , title = 'Coordinates of Seattle-area Airbnbs'
  )
```

<div class="countdown" id="timer_6180b55d" style="right:0;bottom:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">05</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

---

# Troubleshooting exercise 

This code contains 4 mistakes. The code is supposed to create a plot of rentals by latitude and longitude, excluding rentals without ratings. The colors of points should be from the high charts color palette (`hc`). *HINT: It is possible to successfully produce the plot after correcting 3 mistakes, but the colors of the points will be from the default colors palette, not from the high charts palette. Why?*  

![](figures/troubleshooting_solution.png)

---
class: inverse, middle, center

# More on writing logical conditions

---

# More on writing logical conditions

`ifelse()`  
- A logical test with a true-or-false outcome
- To make comparisons use: `==`, `&lt;`, `&lt;=`, `&gt;`, `&gt;=`, `!=`, `%in%`, `!`, `is.na()`
- Concatenate values with `c()`

--

...`ifelse()` is really powerful, but what do you do if there are more than two possible outcomes?

--

&lt;br&gt;&lt;br&gt;
...we use `case_when()`
- *n* conditions result in *n* outcomes

---

# More on writing logical conditions

`case_when()` is similar to `ifelse()` in some ways, but differences abound.

```r
airbnb %&gt;% mutate(expensive = ifelse(price &gt; 100, 'y', NA))
airbnb %&gt;% mutate(expensive = case_when(price &gt; 100 ~ 'y'))
```

--

`case_when()`
- No `FALSE` outcome exists,  always a two-sided formulae
  - left-hand side (LHS) and right-hand side (RHS)
  - Note the use of `~` above to separate LHS and RHS
- All RHS values must be the same type (or class)
  - `NA_character_`, `NA_integer_`, `NA_real_`
- Order of conditions matters if conditions are not mutually exclusive
- A default case of `TRUE ~ NA` is used for all conditions not stated

---

# More on writing logical conditions

`case_when()`
- No `FALSE` outcome exists,  always a two-sided formulae
  - left-hand side (LHS) and right-hand side (RHS)
  - Note the use of `~` above to separate LHS and RHS

```r
airbnb %&gt;% 
  mutate(
    price_cat = case_when(price &lt; 100                  ~ 'low' # first formula
                          , price &gt;= 100 &amp; price &lt; 200 ~ 'mid' # second formula
                          , price &gt;= 200               ~ 'high') # third formula
  )
```

---

# More on writing logical conditions

`case_when()`
- All RHS values must be the same type (or class)
  - `NA_character_`, `NA_integer_`, `NA_real_`


**This will not work**
```r
airbnb %&gt;% 
  mutate(
    priv_share = case_when(room_type %in% c('Private room', 'Shared room') ~ price
                          , room_type == 'Entire home/apt' ~ NA
                          )
    )
```

**This will work**
```r
airbnb %&gt;% 
  mutate(
    priv_share = case_when(room_type %in% c('Private room', 'Shared room') ~ price
                          , room_type == 'Entire home/apt' ~ NA_real_
                          )
    )
```

---

# More on writing logical conditions

`case_when()`
- Order of conditions matters if conditions are not mutually exclusive
- A default case of `TRUE ~ NA` is used for all conditions not stated

```r
airbnb %&gt;% 
  head(2) %&gt;% 
  select(room_id, host_id, rating, accommodates, price) %&gt;% 
  mutate(
    category = case_when(rating == 5 ~ 'High rating'
                        , accommodates &gt;= 6 ~ 'Big!'
                        , price &gt;= 200 ~ 'Expensive'
                        )
    )
```

---

# More on writing logical conditions

.pull-left[
With the `airbnb` data, create a bar plot that shows counts of three different home size categories. 
- Begin by creating a new variable called `home_size`
- `home_size` values should be `"Small"` (two bedrooms or fewer), `"Medium"` (three or four bedrooms), and `"Large"` (more than four bedrooms)
- Only show `Entire home/apt` rentals
- HINT: you can build this plot with aggregated or disaggregated data
  - Disaggregated is easier
- Update the plot aesthetic, plot title, axis titles, etc. if you'd like
]

.pull-right[
![](index_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;
]

<div class="countdown" id="timer_6180b3aa" style="right:0;bottom:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">10</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

---

# More on writing logical conditions

```r
airbnb %&gt;% 
  mutate(
    home_size = case_when(bedrooms &lt;= 2 ~ 'Small'
                          , bedrooms %in% 3:4 ~ 'Medium'
                          , bedrooms &gt; 4 ~ 'Large')
  ) %&gt;% 
  filter(room_type == 'Entire home/apt') %&gt;% 
  ggplot(aes(x = home_size)) +
  geom_bar(fill = 'orange') + 
  scale_y_continuous(labels = comma) + 
  theme_hc() + 
  labs(x = 'Home Size', y = 'Number of Homes')
```

---

# More on writing logical conditions

`ifelse()`  
- A logical test with a true-or-false outcome
- To make comparisons use: `==`, `&lt;`, `&lt;=`, `&gt;`, `&gt;=`, `!=`, `%in%`, `!`, `is.na()`
- **Or use `str_detect()` to search for patterns over strings**

`str_detect()` has three arguments
- `string`, where you are searching for the pattern
- `pattern`, the pattern to look for
- `negate`, whether you want to return matches or non-matches 


```r
california &lt;- c('San Francisco', 'Los Angeles', 'San Diego')

ifelse(str_detect(california, 'San'), 'yes', 'no')
## [1] "yes" "no"  "yes"
```

---

# More on writing logical conditions

`ifelse()`  
- A logical test with a true-or-false outcome
- To make comparisons use: `==`, `&lt;`, `&lt;=`, `&gt;`, `&gt;=`, `!=`, `%in%`, `!`, `is.na()`
- **Or use `str_detect()` to search for patterns over strings**

`str_detect()` has three arguments
- `string`, where you are searching for the pattern
- `pattern`, the pattern to look for
- `negate`, whether you want to return matches or non-matches 

```r
airbnb %&gt;% 
  transmute(
    room_id
    , reviews
    , price
    , cozy = ifelse(str_detect(name, 'cozy'), 'so cozy', 'not so cozy')
    )
```

---

# More on writing logical conditions

`str_detect()` + `tolower()`  
- Casing becomes a problem when searching over strings
- `tolower()` solves that problem

```r
airbnb %&gt;% 
  transmute(
    room_id
    , reviews
    , price
    , urban_1 = ifelse(str_detect(name, 'urban'), 'so urban', 'not so urban')
    , urban_2 = ifelse(str_detect(tolower(name), 'urban'), 'so urban', 'not so urban')
    )
```

---

# More on writing logical conditions

Use `str_detect()` with `ifelse()`, `case_when()`, or `filter()`

```r
airbnb %&gt;% 
  filter(str_detect(name, 'Cozy'))
```

-- 

Use multiple conditions to subset your data with `filter()`

```r
airbnb %&gt;% 
  filter(str_detect(name, 'Cozy') &amp; str_detect(name, 'Quiet'))

airbnb %&gt;% 
  filter(str_detect(name, 'Cozy') | str_detect(name, 'Quiet'))
```


---

# More on writing logical conditions

.pull-left[
Build on your code you from the previous exercise. Create a new variable that you can use to color bar segments, making your bar plot a stacked bar plot. 
- Name the new variable `home_category`
- `home_category` should include the following values: `"Lake"` (where any `name` value contain the word `"lake"`), `"Historic"` (where any `name` value contain the word `"historic"`), `"Modern"` (where any `name` value contain the word `"modern"`)  
- Remember that `case_when()` will set `home_category` to `NA` if cases for `"Lake"`, `"Historic"`, or `"Modern"` are not met
- Exclude rentals with `NA` `home_category` values from your plot. 
]

.pull-right[
![](index_files/figure-html/unnamed-chunk-5-1.png)&lt;!-- --&gt;

![](index_files/figure-html/unnamed-chunk-6-1.png)&lt;!-- --&gt;
]

<div class="countdown" id="timer_6180b3a3" style="right:0;bottom:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">07</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

---

# More on writing logical conditions

```r
airbnb %&gt;% 
  mutate(
    home_size = case_when(bedrooms &lt;= 2 ~ 'Small'
                          , bedrooms %in% 3:4 ~ 'Medium'
                          , bedrooms &gt; 4 ~ 'Large')
    , home_category = case_when(str_detect(tolower(name), 'lake') ~ 'Lake'
                                , str_detect(tolower(name), 'historic') ~ 'Historic'
                                , str_detect(tolower(name), 'modern') ~ 'Modern')
  ) %&gt;% 
  filter(room_type == 'Entire home/apt' &amp; ! is.na(home_category)) %&gt;% 
  ggplot(aes(x = home_size, fill = home_category)) +
  geom_bar() + 
  theme_hc() + 
  scale_fill_hc() + 
  labs(
    x = 'Home Size'
    , y = 'Number of Homes'
    , fill = element_blank()
    ) + 
  theme(legend.position = 'top')
```

---
class: inverse, middle, center

# Pivoting data

---

# Pivoting data

- `pivot_wider()` and `pivot_longer()` are the functions we use to reshape data
- Reshape means to turn...
  - Rows into columns (with `pivot_wider()`), so the new dataset is wider and has fewer rows than the old dataset
  - Columns into rows (with `pivot_longer()`), so the new dataset is narrower, has more rows, and fewer columns than the old dataset
  
&lt;img src="http://garrettgman.github.io/images/tidy-9.png" style="height: 350px"/&gt;

---

# Pivoting data 

- `pivot_wider()` and `pivot_longer()` are the functions we use to reshape data
- Reshape means to turn...
  - Rows into columns (with `pivot_wider()`), so the new dataset is wider and has fewer rows than the old dataset
  - Columns into rows (with `pivot_longer()`), so the new dataset is narrower, has more rows, and fewer columns than the old dataset
  
&lt;img src="http://garrettgman.github.io/images/tidy-8.png" style="height: 400px"/&gt;

---

# Pivoting data 

`pivot_wider()`
- Turn rows into columns
  - Data may be *easier to read* when denormalized (or are in a wider format)
  - Useful format when reporting + useful setting up calculations in specific situations
- 3 arguments
  - `data`, your tibble  
  - `names_from`, name of column that contains the names of the new columns
  - `values_from`, name of columns that contains the values of the new columns

```r
airbnb %&gt;% 
  group_by(address, room_type) %&gt;% 
  summarise(number_of_rentals = n(), .groups = 'drop') %&gt;% 
  pivot_wider(names_from = room_type, values_from = number_of_rentals)
```

--

```r
airbnb %&gt;% 
  group_by(address, room_type) %&gt;% 
  summarise(number_of_rentals = n(), .groups = 'drop') %&gt;% 
  pivot_wider(names_from = room_type, values_from = number_of_rentals) %&gt;%
  mutate(private_or_shared = `Private room` + `Shared room`)
```

---

# Pivoting data 
`pivot_longer()`
- Turn columns into rows
- Often "metrics" are *easier to analyze* when stored in only one column
- 4 arguments
  - `data`, Your tibble 
  - `cols`, which columns you want turn into rows
  - `names_to`, name of column for column names
  - `values_to`, name of column for values in columns
  
```r
airbnb %&gt;% 
  select(room_id, host_id, room_type, address, reviews, rating) %&gt;% 
  pivot_longer(
    cols = c(reviews, rating)
    , names_to = 'rental_characteristics'
    , values_to = 'values'
    )
  
```

---

# Pivoting data 

Complete either Exercise #1 or #2 in 10 minutes. You pick.

**Exercise #1**: With the `climate` data, report the mean temperatures for `"Angola"`, `"Ivory Coast"`, `"Ethiopia"`
, and `"Kenya"` in the years `1850`, `1900`, `1950`, and `2000`
- There should be one row per country
- You should pivot the data so the years are columns like in the example below
- In this exercise you will use `filter()`, `group_by()`, `summarise()`, and `pivot_wider()`

**Exercise #2**: With the `airbnb` data, create a bar plot that shows the average number of bathrooms and bedrooms by room type.
- In this exercise you will use `group_by()`, `summarise()`, and `pivot_longer()`
- To create the plot, you will have a `y` variable; therefore `stat = 'identity'`
- The `names_to` variable you create with `pivot_longer()` should be the variable you use to color the bars and the bars should be unstacked (`position = 'dodge'`)
- Update plot aesthetics as you'd like

<div class="countdown" id="timer_6180b1fd" style="top:0;right:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">10</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

---

# Pivoting data 

.pull-left[

**Exercise #1 hint**

```
##       country 1900 1950 2000 1850
## 1      Angola    -    -    -    -
## 2    Ethiopia    -    -    -    -
## 3 Ivory Coast    -    -    -    -
## 4       Kenya    -    -    -    -
```
]

.pull-right[
**Exercise #2 hint**

![](index_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;
]

---

# Pivoting data 

**Exercise #1**
```r
climate %&gt;% 
  filter(
    country %in% c('Angola', 'Ivory Coast', 'Ethiopia', 'Kenya') 
    &amp; year %in% c(1850, 1900, 1950, 2000)
  ) %&gt;% 
  group_by(country, year) %&gt;% 
  summarise(temp = mean(temp), .groups = 'drop') %&gt;% 
  pivot_wider(names_from = year, values_from = temp, names_sort = TRUE)
```

---

# Pivoting data 

**Exercise #2**
```r
airbnb %&gt;% 
  pivot_longer(
    cols = c(bedrooms, bathrooms)
    , names_to = 'characteristic'
    , values_to = 'count'
    ) %&gt;% 
  group_by(room_type, characteristic) %&gt;% 
  summarise(mean_count = mean(count, na.rm = TRUE), .groups = 'drop') %&gt;% 
  ggplot(aes(x = room_type, y = mean_count, fill = characteristic)) + 
  geom_bar(stat = 'identity', position = 'dodge') + 
  theme_bw() + 
  scale_fill_fivethirtyeight() + 
  labs(x = element_blank(), y = 'Average Count', fill = element_blank())
```

---
class: inverse, middle, center

# Merging tibbles

---

# Merging tibbles

- Merge tibbles with `left_join()`, `inner_join()`, `right_join()`, and `full_join()`
- Used for:
  - Merging data from multiple sources
  - Filtering
- Arguments
  - `x`, left tibble
  - `y`, right tibble
  - `by`, keys used to "link" or merge tibbles


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
